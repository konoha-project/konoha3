/****************************************************************************
 * Copyright (c) 2012, Masahiro Ide <ide@konohascript.org> All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ***************************************************************************/

import("konoha.new");
import("js4.string");
import("konoha.foreach");
import("konoha.ns");
import("js4.array");
import("konoha.file");
import("konoha.class");
import("cstyle");
import("konoha.field", ".");

String readFile(String path) {
    FILE file = new FILE(path, "r");
    int len = 0;
    String tmp = "";
    while (true) {
        int ch = file.getc();
        if(ch == -1) {
            break;
        }
        tmp = tmp + String.fromCharCode(ch);
        len = len + 1;
    }
    file.close();
    return tmp;
}

class IR {
    int opcode;
    String name;
    String[] args;
    String[] types;
    String   ops;
};

IR parse(String line) {
    int start = "def ".length;
    int end   = line.length - ") ::".length - start;
    String tmp = line.substr(start, end);
    String[] a = tmp.split("(");
    String opname = a.get(0);
    String[] args = a.get(1).split(",");

    if(args[0] == "") {
        args.clear();
    }
    IR ir = new IR();
    ir.name = opname;
    ir.ops  = "";
    ir.args  = [];
    ir.types = [];
    int i = 0;
    while (i < args.length) {
        String[] param = args[i].split(":");
        ir.args.add(param.get(0).trim());
        ir.types.add(param.get(1).trim());
        i = i + 1;
    }
    return ir;
}

void parseFile(IR[] irs, String data) {
    int opcode = 0;
    String[] defs = data.split("\n");
    int i, len = defs.getlength();
    IR current;
    while (i < len) {
        if(defs[i].startsWith("def")) {
            IR parsedIR = parse(defs[i]);
            current = parsedIR;
            irs.add(parsedIR);
        }
        else if(defs[i] != "") {
            assert(current.name != "");
            current.ops = current.ops + defs[i] + "\\\n";
        }
        i = i + 1;
    }
}

String printTypedef(IR ir) {
    String ret = "";
    ret = ("#define OPCODE_${ir.name} ${ir.opcode}\n");
    ret = ret + ("typedef struct OP${ir.name} {\n");
    int i = 0;
    ret = ret + ("    LIRHeader Header;\n");
    while (i < ir.types.length) {
        ret = ret + ("    ${ir.types.get(i)} ${ir.args[i]};\n");
        i = i + 1;
    }
    ret = ret + ("} PACKED OP${ir.name};\n\n");
    return ret;
}

String printDumpCode(IR ir) {
    int i = 0;
    int len = ir.types.length;
    String ret = "#define OPFIELDSIZE_${ir.name} ${len}\n"
    ret = ret +  "#define DUMP_${ir.name}(OP_${len}) OP_${len}(${ir.name}";
    while (i < len) {
        ret = ret + ", ${ir.types.get(i)}, ${ir.args[i]}";
        i = i + 1;
    }
    ret = ret + ")\n\n";
    return ret;
}

String printMethodDef(IR ir) {
    String ret = "";
    ret = ("#define OPEXEC_${ir.name}(PC) do {\\\n");
    int i = 0;
    while (i < ir.types.length) {
        ret = ret + "    ${ir.types[i]} ${ir.args[i]} = ((OP${ir.name} *)PC)->${ir.args[i]};\\\n";
        i = i + 1;
    }
    ret = ret + ("${ir.ops}} while(0)\n\n");
    return ret;
}

void emit(String path, String data) {
    FILE file = new FILE(path, "w");
    file.print("/* This file was automatically generated by GenLIR.k. Do not edit! */\n");
    file.print("#ifndef LIR_H\n");
    file.print("#define LIR_H\n\n");
    file.print(data);
    file.print("#endif /* end of include guard */");
}

void main (String[] args) {
    String data = readFile("./LIR.def");
    IR[] irs = [];
    parseFile(irs, data);
    int i = 0;
    String ret = "";
    while (i < irs.length) {
        IR ir = irs[i];
        ir.opcode = i;
        ret = ret + printTypedef(ir);
        //ret = ret + printMethodDef(ir);
        ret = ret + printDumpCode(ir);
        i = i + 1;
    }
    i = 0;
    String oplist = "#define BYTECODE_LIST(OP)\\\n";
    while (i < irs.length) {
        IR ir = irs[i];
        oplist = oplist + "    OP(${ir.name})";
        if(i + 1 != irs.length) {
            oplist = oplist + "\\";
        }
        oplist = oplist + "\n";
        i = i + 1;
    }
    ret = ret + oplist + "\n";
    emit("./LIR.h", ret);
}

main([]);
